custom records should have name and lore (title and author)
custom color?

nbt should have dictionary and raw data

what's the deal with registry sync?

for client with unknown sound, play nothing for that note and show in toast notif


opt A:
normal jukebox should play mono

custom should play stereo with speakers

maybe something with headphones?
(render the wire lol)

opt B:
normal jukebox should play stereo and just get quieter the further away you are


volume directly correlates with distance
distance = volume > 1.0F ? (double)(16.0F * volume) : 16.0

portable recorder for note block setups?

Lacquer
1 log/wood block

blank record in existing loot tables
or
L = lacquer
I = iron

L
I
L
or
LL
II

vinyl press

(maybe) Direct Metal Mastering?
copper blanks as master
C = copper

CC

diamond stylus
DMM Lathe


Broadcaster (server)
keep disc data in item nbt
maybe have item have uuid?
make jukebox block entity send custom packet when player enters radius
    - when client gets the packet, decode record data to Score and store in uuid to Score map (cache on client)
s2c packet includes the included music disc (uuid or ItemStack, not sure yet) and current tick
    - when client gets the packet, make a Player from the Score
s2c packet sent to all users in radius if interrupted, either thru isDone or thru specific events (ex jukebox break, disc eject)

Score (client/server??? not sure yet)
holds record data
can create Players

Player (client)
plays the associated sounds on each tick, maybe display thing on InGameHud on start

Recorder/Reciever (server)
takes in all sounds around it (server side)
inject into ServerWorld.playSound?

Disk (???)
holds Score
holds uuid

(at some point) midi conversion?


sound relative to block out of jukebox
output:
relative = false
pos = block + relative sound pos

sound relative to player out of headphones
output:
relative = true
pos = relative sound pos

only records get their sounds stopped (i think), so ignore stops for now

format:

per tick:
option 1:
2 bytes tick no. (unsigned)
1 byte sound count (unsigned)
(count * 24) byte sound list
option 2 (final tick):
2 bytes tick no. (unsigned)
1 byte sound count (value of 0)

per sound:
4 byte id (unsigned)
4 byte float relative x pos
4 byte float relative y pos
4 byte float relative z pos
4 byte float volume
4 byte float pitch

store record uuid/hash -> data in LMDB

delete LMDB entry if no instances of items exist anymore.
server cleanup after time elapsed or during save
maybe turn into command? could take a long time.

client never cleanup?
should clients even have file based dbs? should they instead be per-run maps?

add custom made sample discs to creative menu and dungeons

bring record player closer to recorder and abstract registries

account for record player block rotation to impact relative sound positions
